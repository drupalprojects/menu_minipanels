<?php
/**
 * @file
 *
 * Allows an administrator to specify a minipanel to be associated with a
 * Drupal menu item. When that menu item is hovered or clicked (as per config),
 * the minipanel content will be shown using the qTip javascript library.
 *
 * Technical Overview:
 *
 * There's no way for this code to know what menu items will be used on what
 * pages.
 *
 * This presents a problem.
 *
 * Generally, menu trees are rendered in one of two ways: theme_links and
 * theme_menu_tree.
 *
 * theme_menu_tree() is easy to intercept, as it's usually called within a
 * module, block or preprocess_page, and therefore our code can still get any
 * menu_minipanels js and html included in $closure.
 *
 * However, theme_links is used by most themes for $primary_links and
 * $secondary_links.
 *
 * Because the theme_links function is usually called within page.tpl.php,
 * rather than in a preprocess_page function, it is called *after* $closure
 * is created. Therefore, our general method of including the appropriate js
 * config and panels html output wont work.
 *
 * The method I have used is to assume that primary_links and secondary_links
 * will always be used on a page, so load them in menu_minipanels_init(), find
 * any menu minipanel items, and add the code to the queue for $closure that
 * way. Then still intercept the theming functions in order to add the class
 * names.
 *
 * There's no clean way to get around this as far as I can see, *without*
 * inserting a menu_minipanels closure function call at the end of a theme.
 *
 * That is of course a piece of cake for technical users, but I want this
 * module to be able to be used out of the box by the widest range of users
 * possible. Hackers gonna hack anyway.
 *
 * I may include a configuration option for technical users at a later date if
 * there is any demand.
 */

/**
 * Implements hook_init().
 */
function menu_minipanels_init() {
  // The main qTip script file should be stored in sites/all/libraries/qtip.
  $qtip_path = menu_minipanels_get_qtip_path();

  // If the qTip script isn't found, no point in continuing.
  if ($qtip_path === FALSE) {
    return;
  }

  // The path to this module.
  $path = drupal_get_path('module', 'menu_minipanels');

  // Load the module's custom CSS.
  drupal_add_css($path . '/css/menu_minipanels.css', 'module', 'all', TRUE);

  // This module's custom JS.
  drupal_add_js($path . '/js/menu_minipanels.js');

  // Load the qTip script.
  drupal_add_js($qtip_path);

  // Most themes will call primary and secondary links on every page.
  // They are usually themed by a function call inside page.tpl.php so we
  // can't wait until theme_links is called, because by that time, $closure
  // has already been created, and therefore our code would not be included.
  // Therefore, we ought to load any mini panels primary and secondary links
  // may have.
  $theme_settings = theme_get_settings();
  $primary_links = $theme_settings['toggle_primary_links'] ? menu_primary_links() : array();
  menu_minipanels_preprocess_links_at_init($primary_links);
  $secondary_links = $theme_settings['toggle_secondary_links'] ? menu_secondary_links() : array();
  menu_minipanels_preprocess_links_at_init($secondary_links);
}

/**
 * Check different paths to find the qTips JS file's path.
 *
 * @return The path to the required qTips file relative to base_path() if
 *   found, FALSE if the file is not found.
 */
function menu_minipanels_get_qtip_path() {
  static $qtip_path = FALSE;

  if (empty($qtip_path)) {
    $cid = 'menu_minipanels_qtip_path';
    $cache = cache_get($cid);

    // The path was previously cached, so just load that.
    if (!empty($cache->data)) {
      $qtip_path = $cache->data;
    }

    // There was no cached data, so get the path & cache it for later.
    else {
      $filename = 'jquery.qtip-1.0.0-rc3.min.js';
      $module_path = drupal_get_path('module', 'menu_minipanels');

      // An array of possible paths, in descending order of preference.
      $possible_paths = array(
        // Ideally should be stored here.
        'sites/all/libraries/qtip',
        // Legacy paths, including some possible incorrect ones, but the
        // performance hit should be negligible.
        $module_path . '/js/lib/qtip',
        $module_path . '/js/lib',
        $module_path . '/js/qtip',
        $module_path . '/js',
        $module_path . '/qtip',
        $module_path,
      );

      // Check each of the paths.
      foreach ($possible_paths as $path) {
        // If the file exists, this is the one we'll use.
        if (file_exists($path . '/' . $filename)) {
          $qtip_path = $path . '/' . $filename;
          continue;
        }
      }

      // Save the path for later.
      if (!empty($qtip_path)) {
        cache_set($cid, $qtip_path);
      }
      else {
        watchdog('menu_minipanels', t('Menu Minipanels module is enabled, but the qTip library has not been downloaded. This module will not work without qTip! Please see README.txt for instructions on how to download qTip.'));
      }
    }
  }

  // Return the qTips JS file's path, or FALSE.
  return $qtip_path;
}


/**
 * Implements hook_help().
 */
function menu_minipanels_help($path, $arg) {
  switch ($path) {
    case 'admin/settings/menu_minipanels':
      return '<p>'. t('The menu minipanels module integrates the very popular qTip tooltip library into Drupal. Visit the <a href="!reference_url">qTip reference</a> to learn about the various configuration options.', array('!reference_url' => 'http://craigsworks.com/projects/qtip/')) .'</p>';
  }
}

/**
 * Implements hook_menu().
 */
function menu_minipanels_menu() {
  $items = array();
  $items['admin/settings/menu_minipanels'] = array(
    'title' => 'Menu Minipanels Settings',
    'description' => 'Configure the Menu Minipanels module',
    'page callback' => 'drupal_get_form',
    'page arguments' =>  array('menu_minipanels_admin'),
    'access arguments' => array('administer site configuration')
  );

  return $items;
}

/**
 * Implements hook_form_alter().
 */
function menu_minipanels_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'menu_edit_item') {
    // Check to see whether the menu form exists.
    if (isset($form['menu'])) {
      // Load the admin code necessary for this.
      module_load_include('inc', 'menu_minipanels', 'menu_minipanels.admin');

      $path = drupal_get_path('module', 'menu_minipanels');
      drupal_add_js($path . '/js/menu_minipanels_admin.js');

      $form['menu']['options'] = array(
        '#type' => 'markup',
        '#title' => t('Menu item minipanel'),
        '#access' => user_access('administer menu'),
        '#collapsible' => FALSE,
        '#collapsed' => FALSE,
        '#tree' => TRUE,
        '#weight' => 50,
      );

      // Load minipanels.
      ctools_include('plugins', 'panels');
      $layouts = panels_get_layouts();
      $panel_minis = panels_mini_load_all();

      // Create options for select box.
      $options = array('' => 'None');
      foreach ($panel_minis as $panel_mini) {
        // Compatibility with older versions of minipanels.
        $title = '';
        if (!empty($panel_mini->title)) {
          $title = check_plain($panel_mini->title);
        }
        else {
          $title = check_plain($panel_mini->admin_title);
        }
        $options[check_plain($panel_mini->name)] = $title;
      }

      $item = $form['menu']['#item'];
      $form['menu']['options']['minipanel'] = array(
        '#type' => 'select',
        '#title' => t('Menu minipanel'),
        '#description' => t('Choose the minipanel to display.'),
        '#default_value' => isset($item['options']['minipanel']) ? $item['options']['minipanel'] : '',
        '#options' => $options,
        '#required' => FALSE,
      );

      $form['#validate'][] = 'menu_minipanels_menu_edit_item_validate';

      _menu_minipanels_hover_settings_form($form['menu']['options'], $form['menu']['#item']['options']['menu_minipanels_hover'], variable_get('menu_minipanels_hover', _menu_minipanels_hover_defaults()));
    }

    // This is prepended to the array to ensure it is executed before
    // menu_edit_item_submit(). If it is executed after menu_edit_item_submit,
    // then the menu_minipanels_hover array will be saved to the database
    // anyway, and the intercept would be pointless.
    array_unshift($form['#submit'], 'menu_minipanels_menu_edit_item_submit');
  }
}

/**
 * If no minipanel is set, stop minipanel settings being saved.
 */
function menu_minipanels_menu_edit_item_submit($form, &$form_state) {
  if ($form_state['values']['menu']['options']['minipanel'] == '') {
    unset($form_state['values']['menu']['options']['menu_minipanels_hover']);
  }
  else {
    // Store mlid for later use in uniquely identifiying menu configs in the
    // javascript.
    $form_state['values']['menu']['options']['menu_minipanels_hover']['mlid'] = $form_state['values']['menu']['mlid'];
  }
}

/**
 * Implements hook_theme_registry_alter().
 *
 * Theme preprocess functions aren't called if the theme is in a function.
 *
 * This hacks a preprocess function for theme_menu_item_link() in a way that
 * won't interfere with other themes or modules that override
 * theme_menu_item_link().
 *
 * theme_menu_item_link() is overridden because to print menus, themes and
 * modules generally use menu_tree_output(), and menu_tree_output() calls
 * theme_menu_item_link().
 *
 * This method *only* works if theme_menu_item_link is called *before* $closure
 * is created in page_preprocess().
 *
 * If a theme calls theme('menu_tree') in a page.tpl.php for instance, this
 * will not work.
 *
 * To get it to work, the theme will need to implement hook_page_preprocess and
 * add a variable to $vars, so that the theme_menu_item_link() is called
 * *before* $closure.
 */
function menu_minipanels_theme_registry_alter(&$vars) {
  $vars['links']['old function'] = $vars['links']['function'];
  $vars['links']['function'] = 'menu_minipanels_preprocess_links';

  $vars['menu_item_link']['old function'] = $vars['menu_item_link']['function'];
  $vars['menu_item_link']['function'] = 'menu_minipanels_preprocess_menu_item_link';

  // Must come first before template_preprocess, in order to be called before
  // template css is set in template_preprocess, so that panels may add its css,
  // and have it included.
  $vars['page']['preprocess functions'] = array_merge(array('menu_minipanels_preprocess_page_hidden'), $vars['page']['preprocess functions']);
}

/**
 * Ensure that we capture any mini panel menus that are set in $primary_links
 * or $secondary_links. This is run on every page load.
 * See @menu_minipanels_init().
 */
function menu_minipanels_preprocess_links_at_init($links) {
  foreach ($links as $link) {
    if (!empty($link['minipanel'])) {
      $prefix = '';
      if (!empty($link['attributes']['class'])) {
        $prefix = $link['attributes']['class'] . ' ';
      }
      $link['attributes']['class'] = $prefix . _menu_minipanels_include($link['minipanel'], $link['menu_minipanels_hover']);
    }
  }
}

/**
 * See @menu_minipanels_theme_registry_alter().
 * Also see @menu_minipanels_init() and
 * menu_minipanels_preprocess_links_at_init().
 */
function menu_minipanels_preprocess_links($links, $attributes = array('class' => 'links')) {
  foreach ($links as &$link) {
    if (!empty($link['minipanel'])) {
      $prefix = '';
      if (!empty($link['attributes']['class'])) {
        $prefix = $link['attributes']['class'] . ' ';
      }
      // Only set the class names, don't include the code. That has already
      // been done earlier in @menu_minipanels_preprocess_links_at_init().
      $link['attributes']['class'] = $prefix . _menu_minipanels_link_class_name($link['menu_minipanels_hover']['mlid']);
    }
  }
  $registry = theme_get_registry();
  return $registry['links']['old function']($links, $attributes);
}

/**
 * See @menu_minipanels_theme_registry_alter.
 */
function menu_minipanels_preprocess_menu_item_link($link) {
  $matches = array();
  if (!empty($link['options']['minipanel'])) {
    if (empty($link['localized_options'])) {
      $link['localized_options'] = array('attributes' => array());
    }
    $prefix = '';
    if (!empty($link['localized_options']['attributes']['class'])) {
      $prefix = $link['localized_options']['attributes']['class'] . ' ';
    }
    $link['localized_options']['attributes']['class'] = $prefix . _menu_minipanels_include($link['options']['minipanel'], $link['options']['menu_minipanels_hover']);
  }
  $registry = theme_get_registry();
  return $registry['menu_item_link']['old function']($link);
}

/**
 * The panels need to be rendered *after* init so as to not cause theme
 * problems, but *before* closure, so as be sure that panels css gets
 * included.
 * 
 * We don't do anything with variables, we just use preprocess_page() as its at
 * called at time time.
 */
function menu_minipanels_preprocess_page_hidden(&$variables) {
  $output = '';
  foreach (menu_minipanels_panels(NULL, NULL) as $mlid => $minipanel_name) {
    $html = '<div class="menu-minipanels menu-minipanel-' . $mlid . '">' . _menu_minipanels_render_panel($minipanel_name) . '</div>';
    $output .= $html;
  }
  menu_minpanels_html($output);
}

/**
 * Implements hook_footer().
 *
 * Add all the required minipanel output to the closure.
 * See @_menu_minipanels_include.
 */
function menu_minipanels_footer() {
  return menu_minpanels_html();
}

function menu_minpanels_html($html = NULL) {
  static $stored = '';
  if ($html != NULL) {
    $stored = $html;
  }
  else {
    return $stored;
  }
}

/**
 * Stores the names of all rendered minipanels through the page load.
 * Will later be used by @menu_minipanels_footer to add all required minipanels
 * to $closure.
 * See @menu_minipanels_footer and @_menu_minipanels_include.
 * @param Int $mlid - the menu item id that needs the minipanel rendered.
 * @param String $minipanel - the name of the minipanel to render.
 */
function menu_minipanels_panels($mlid = NULL, $name = NULL) {
  static $panels = array();
  if ($name != NULL) {
    $panels[$mlid] = $name;
  }
  else {
    return $panels;
  }
}

/**
 * When a minipanel menu item is detected by our theme interception functions
 * this function is used to add the appropriate configuration javascript
 * and minipanel output.
 *
 * The javascript is added to the closure by drupal when hook_footer is called.
 * The minipanel output is added to closure. See @menu_minipanels_footer
 *
 * @param $minipanel_name The name of the minipanel that is to show
 * @param $menu_config The configuration array for qtip, as configued in menu
 *   item edit
 */
function _menu_minipanels_include($minipanel_name, $menu_config) {
  $mlid = $menu_config['mlid'];
  unset($menu_config['mlid']);
  
  // The same panel/mlid may be added multiple times, if the same menu is added
  // to a page more than once, i.e. the primary links, plus primary links also
  // added as a block.
  static $added = array();
  if (!isset($added[$mlid])) {
    $added[$mlid] = TRUE;
  }
  else {
    return _menu_minipanels_link_class_name($mlid);
  }
    
  // qTip interprets the absence of the 'position' array element as 'false'.
  // specifying 'false' doesn't work.
  if ($menu_config['position']['target'] == 'element') {
    unset($menu_config['position']['target']);
  }

  // qTip interprets the absence of the 'tip' array element as "don't display
  // a tip". Specifying 'false' doesn't work.
  if ($menu_config['style']['tip'] == 'none') {
    unset($menu_config['style']['tip']);
  }

  // Remove blank values.
  if (isset($menu_config['hide']['effect']['length']) && $menu_config['hide']['effect']['length'] == '') {
    unset($menu_config['hide']['effect']['length']);
  }
  if (isset($menu_config['show']['effect']['delay']) && $menu_config['show']['effect']['delay'] == '') {
    unset($menu_config['show']['effect']['delay']);
  }
  if (isset($menu_config['show']['effect']['length']) && $menu_config['show']['effect']['length'] == '') {
    unset($menu_config['show']['effect']['length']);
  }
  if (isset($menu_config['style']['border']['color']) && $menu_config['style']['border']['color'] == '') {
    unset($menu_config['style']['border']['color']);
  }
  if (isset($menu_config['style']['border']['radius']) && $menu_config['style']['border']['radius'] == '') {
    unset($menu_config['style']['border']['radius']);
  }
  if (isset($menu_config['style']['border']['width']) && $menu_config['style']['border']['width'] == '') {
    unset($menu_config['style']['border']['width']);
  }
  if (isset($menu_config['style']['border']) && empty($menu_config['style']['border'])) {
    unset($menu_config['style']['border']);
  }
  if (isset($menu_config['style']['width']['max']) && $menu_config['style']['width']['max'] == '') {
    unset($menu_config['style']['width']['max']);
  }
  if (isset($menu_config['style']['width']['min']) && $menu_config['style']['width']['min'] == '') {
    unset($menu_config['style']['width']['min']);
  }
  if (isset($menu_config['style']['width']) && empty($menu_config['style']['width'])) {
    unset($menu_config['style']['width']);
  }

  $settings = array(
    'menuMinipanels' => array(
      'panels' => array(
        'panel_' . $mlid => $menu_config,
      )
    )
  );
  drupal_add_js($settings, 'setting');

  // Load the necessary style JS file.
  module_invoke_all('menu_minipanels_style', $menu_config);

  menu_minipanels_panels($mlid, $minipanel_name);
  return _menu_minipanels_link_class_name($mlid);
}

/**
 * Seperated out as it may be called independently by our function that
 * intercepts theme_links().
 */
function _menu_minipanels_link_class_name($minipanel_name) {
  return 'menu-minipanel menu-minipanel-' . $minipanel_name;
}

/**
 * Code based on panels_mini_block() in panels_mini.module.
 */
function _menu_minipanels_render_panel($minipanel_name) {
  $panel_mini = panels_mini_load($minipanel_name);
  if (empty($panel_mini)) {
    return '';
  }
  ctools_include('context');
  $panel_mini->context = $panel_mini->display->context = ctools_context_load_contexts($panel_mini);
  $panel_mini->display->css_id = panels_mini_get_id($panel_mini->name);
  return panels_render_display($panel_mini->display);
}
